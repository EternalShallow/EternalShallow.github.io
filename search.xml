<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo Course]]></title>
    <url>%2F2019%2F05%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new "My New Post" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[async+phantomjs制作nodejs的小说爬虫]]></title>
    <url>%2F2019%2F04%2F26%2Fnode-novel%2F</url>
    <content type="text"><![CDATA[async+phantomjs制作nodejs的小说爬虫 内容要点 一步一脚印实现一个爬虫,文章内容较长,建议在pc下阅读 源码地址 phantomjs捕获内容 详细介绍通过async.mapLimit并发处理,结合定时器进行延时执行 数据输出成文件保存到本地 (如有错误请大家指出，一起学习) 目录结构 12345678910111213.├── README.md├── asyncFetch.js├── book│ └── default├── mock│ └── bookInfo.json├── fetchAllChapters.js├── fetchChapter.js├── note.md├── package.json├── taskHandler.js├── test.js 介绍(有了解可以直接跳过) 关于PhantomJS 首先介绍一下phantomjs PhantomJS是一个基于WebKit的服务器端JavaScript API，它基于 BSD开源协议发布。PhantomJS无需浏览器的支持即可实现对Web的支持，且原生支持各种Web标准，如DOM 处理、JavaScript、CSS选择器、JSON、Canvas和可缩放矢量图形SVG。PhantomJS主要是通过JavaScript和CoffeeScript控制WebKit的CSS选择器、可缩放矢量图形SVG和HTTP网络等各个模块。 phantomjs的应用场景 无需浏览器的Web测试：无需浏览器的情况下进行快速的Web测试，且支持很多测试框架，如YUI Test、Jasmine、WebDriver、Capybara、QUnit、Mocha等。 页面自动化操作：使用标准的DOM API或一些JavaScript框架（如jQuery）访问和操作Web页面。 屏幕捕获：以编程方式抓起CSS、SVG和Canvas等页面内容，即可实现网络爬虫应用。构建服务端Web图形应用，如截图服务、矢量光栅图应用。 网络监控：自动进行网络性能监控、跟踪页面加载情况以及将相关监控的信息以标准的HAR格式导出。 基于phantomjs2.0进行实现有两种实现方案，一种是使用基于全局的 http://phantomjs.org/ ，另外一种是封装的模块 phantom - Fast NodeJS API for PhantomJS -https://github.com/amir20/phantomjs-node 这里选择phantomjs-node 关于phantomjs-node的安装以及入门 使用可以根据百度前端学院2017中的网页抓取分析服务系列相关内容中学习,这里放一下之前phantomjs-node 学习的笔记和demo 中的phantomjs_1~4目录下 后文也会进一步说明使用方法。 实现思路和过程 实现思路 phantomjs就相当于一个无图形界面的浏览器,那么我们提供连接给phantomjs就意味着我们能获取这个url的内容。 这次爬虫的内容是希望获取到小说的所有章节以及其内容,直接以笔阁网为例,因为这次爬虫是直接爬笔阁网的。 我们打开http://www.qu.la/book/5443, 上面就有这本小说的许多章节,所以就有了第一步,或者这个页面上所有章节,通过&quot;开发者工具&quot;中的检查共功能 我们可以看到知道内容是这样的结构 123456&lt;div id =&quot;list&quot;&gt;&lt;dd&gt;&lt;a href=&quot;/**&quot;&gt;第xx章&lt;/a&gt;&lt;/dd&gt;....&lt;/div&gt; 所以只要我们获取 id为list 中所有的dd,就获取了小说的所有章节,同时通过dd中a标签的href属性就可以连接到所有章节的内容。 爬虫方面的思路说明到这里 实现过程 (请保证node版本高于7.9,本文基于7.10.0) (最好先了解es7中async/await 以及child_process) 如何使用phantomjs-nodejs 如何运行代码？。。 将代码保存在一个js文件中例如test.js 然后运行 1node test.js 参考 123456789101112131415161718192021const phantom = require(&apos;phantom&apos;);//导入模块//async解决回调问题,es7的内容(async function() &#123; // await解决回调问题，创建一个phantom实例 const instance = await phantom.create(); //通过phantom实例创建一个page对象，page对象可以理解成一个对页面发起请求和处理结果这一集合的对象 const page = await instance.createPage(); //页面指向的是哪个一个url await page.on(&quot;onResourceRequested&quot;, function(requestData) &#123; console.info(&apos;Requesting&apos;, requestData.url) &#125;); //得到打开该页面的状态码 const status = await page.open(&apos;https://stackoverflow.com/&apos;); console.log(status);//输出该页面的内容 const content = await page.property(&apos;content&apos;); console.log(content); //输出内容 //退出该phantom实例 await instance.exit();&#125;()); 输出结果 当然不可能直接使用这些内容,所以就需要通过 12//这个方法,我的理解是跟你在chrome中的输出台的操作是一样的所以看看下面栗子await page.evaluate(function() &#123;&#125;); 12345678910111213141516171819202122232425const phantom = require(&apos;phantom&apos;);let url = encodeURI(`https://www.baidu.com/s?wd=&quot;hello&quot;`);(async function() &#123; const instance = await phantom.create(); const page = await instance.createPage(); const status = await page.open(url); if (status !== &apos;success&apos;) &#123; console.log(&quot;访问失败&quot;); return; &#125; else &#123; let start = Date.now(); let result = await page.evaluate(function() &#123; return document.title &#125;); let data = &#123; cose: 1, msg: &quot;抓取成功&quot;, time: Date.now() - start, dataList: result &#125; console.log(JSON.stringify(data)); await instance.exit(); &#125;&#125;()); 输出结果 模块实现 获取所有章节fetchAllChapters.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566const phantom = require(&apos;phantom&apos;);const program = require(&apos;commander&apos;);/* 命令行参数帮助工具 设置 option b 代表 book ,[book]表示该参数可以通过program访问,这个参数表示书本编号 命令 eg: node fetchAllChapters.js -b 5443*/program .version(&apos;0.1.0&apos;) .option(&apos;-b, --book [book]&apos;, &apos;book number&apos;) .parse(process.argv);//缺少书本参数直接退出if (!program.book) &#123; return&#125;// example &quot;5443&quot;,获取书本编号const bookNumber = program.book //访问的urlconst url = encodeURI(`http://www.qu.la/book/$&#123;bookNumber&#125;/`);//设置用户代理头const userAgent = `Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36`try &#123; //提供async环境 (async function() &#123; //创建实例 const instance = await phantom.create() //创建页面容器 const page = await instance.createPage() //设置 page.setting(&quot;userAgent&quot;, userAgent) //判断是否访问成功 const status = await page.open(url), code = 1; if (status !== &apos;success&apos;) &#123; //访问失败修改状态码 code = -1; &#125; else &#123; //获取当前时间 var start = Date.now(); var result = await page.evaluate(function() &#123; var count = 1; return $(&apos;#list dl dd&apos;).map(function() &#123; return (&#123; index: count++, title: $(this).find(&apos;a&apos;).html(), link: url + ($(this).find(&apos;a&apos;).attr(&apos;href&apos;)).substring(($(this).find(&apos;a&apos;).attr(&apos;href&apos;)).lastIndexOf(&quot;/&quot;)), &#125;) &#125;).toArray() &#125;) let data = &#123; code: code, bookNumber: &quot;5443&quot;, url: url, time: Date.now() - start, dataList: result &#125; console.log(JSON.stringify(data)); &#125; //退出实例 await instance.exit(); &#125;)()&#125; catch (e) &#123; console.log(e)&#125; 输出结果 在获取所有章节之后,我们需要获取所有章节的内容了 fetchChapter 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132const phantom = require(&apos;phantom&apos;);const mkdirp = require(&apos;mkdirp&apos;)const program = require(&apos;commander&apos;);const fs = require(&apos;async-file&apos;)const path = require(&apos;path&apos;)//设置用户代理const userAgent = `Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36`/*命令行参数p -替换原文本中的换行空格f -保存为文件t 自定义输出路径u 抓取单章的url*/program .version(&apos;0.1.0&apos;) .option(&apos;-p, --puer&apos;, &apos;puerMode&apos;) .option(&apos;-f, --file&apos;, &apos;save2File&apos;) .option(&apos;-t, --path [path]&apos;, &apos;outPutPath&apos;) .option(&apos;-u, --url [url]&apos;, &apos;url&apos;) .parse(process.argv);if (!program.url) &#123; return;&#125;const URL = program.url;const DEFAULT_PATH = &apos;/book/default/&apos;;/*替换br和&amp;nbsp标签*/function puer(str) &#123; if (!str) &#123; return &#125; str = str.replace(/&lt;br\s*\/?&gt;/gi, &quot;\r\n&quot;); str = str.replace(/&amp;nbsp;/g, &quot; &quot;) return str&#125;/*test urlnode fetchChapter.js -u http://www.qu.la/book/5443/3179374.html -f -p*/(async function () &#123; let code = 1 //创建实例 const instance = await phantom.create() //创建页面容器 const page = await instance.createPage() page.setting(&quot;userAgent&quot;, userAgent) const status = await page.open(URL) if (status !== &apos;success&apos;) &#123; code = -1; return; &#125; else &#123; var start = Date.now(); var result = await page.evaluate(function () &#123; //移除一些无关内容(等于直接在结果网页上的dom上进行操作) //请注意这里如果调用console.log()是无效的! $(&quot;#content a:last-child&quot;).remove() $(&quot;#content script:last-child&quot;).remove() $(&quot;#content div:last-child&quot;).remove() $(&quot;#content script:last-child&quot;).remove() return (&#123; novelName: $(&quot;#page_set&quot;).next().next().html(), title: $(&quot;h1&quot;).html(), content: $(&quot;#content&quot;).html() &#125;); &#125;) if (result.title == &apos;&apos; || result.content == &apos;&apos;) &#123; //内容为空捕获失败 console.log(JSON.stringify(&#123; code: -1 &#125;)) return &#125; else &#123; //判断参数进一步处理 if (program.puer) &#123; var context = &apos;---\n&apos; + &apos;layout: \&apos;[literature]\&apos;\n&apos; + &apos;title: &apos; + result.title + &apos;\n&apos;+ &apos;date: &apos; + new Date().getFullYear() + &apos;-&apos; + ((new Date().getMonth() + 1) &gt; 10 ? (new Date().getMonth() + 1) : (&apos;0&apos; + (new Date().getMonth() + 1))) + &apos;-&apos; + (new Date().getDate() &gt; 10 ? new Date().getDate() : (&apos;0&apos; + new Date().getDate())) + &apos; &apos; + new Date().getHours() + &apos;:&apos; + new Date().getMinutes() + &apos;:&apos; + new Date().getSeconds() + &apos;\n&apos; + &apos;tags: [文学,小说,&apos;+ result.novelName +&apos;]\n&apos; + &apos;copyright: true\n&apos; + &apos;toc_number: true\n&apos; + &apos;categories: [文学,小说,&apos;+ result.novelName +&apos;]\n&apos; + &apos;comments: true\n&apos; + &apos;toc: true\n&apos; + &apos;abbrlink: f6d1cfff\n&apos; + &apos;description: &apos; + result.content.trim().substring(0,20) + &apos;...&apos; +&apos;\n&apos; + &apos;---&apos; context += puer(result.content) &#125; //文件模式处理后进行保存到文件.返回文件路径 if (program.file) &#123; let path = &quot;&quot; if (program.path) &#123; //自定义路径 &#125; else &#123; path = DEFAULT_PATH; //避免文件夹不存在,__dirname指向的是文件所在路径 mkdirp( __dirname + path, (err) =&gt; &#123; // mkdirp(&apos;../&apos; + __dirname + path, (err) =&gt; &#123; if (err) &#123; console.log(err); &#125; &#125;) //拼接出文件输出的路径 path += result.title + &quot;.md&quot;; await fs.writeFile(__dirname + path, context) //输出文件名 console.log(JSON.stringify(&#123; code: 1, filePath: path &#125;)) &#125; &#125; else &#123; console.log(JSON.stringify(&#123; code: 1, content: result &#125;)); &#125; &#125; &#125; //exit await instance.exit();&#125;)() 拓展 1234await page.includeJs(&quot;https://cdn.bootcss.com/jquery/1.12.4/jquery.js&quot;)//可以导入其他js libawait page.render(&apos;germy.png&apos;);//渲染当前页面为图片输出 在这里说一下为什么可以直接使用jquery,以百度为例子 因为当前页面加载的时候加载了jquery 这个lib,所以这里就可以直接使用了 结合使用 taskHandler 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166const exec = require(&apos;child_process&apos;).exec;const execAsync = require(&apos;async-child-process&apos;).execAsync;const async = require(&apos;async&apos;)const delayAsync = require(&apos;./asyncFetch&apos;).delayAsync;const program = require(&apos;commander&apos;);var fs = require(&apos;fs&apos;);const util = require(&apos;util&apos;)const co = require(&apos;co&apos;)const readAsync = util.promisify(fs.readFile)let cmd;/*s 是章节开始(下标是0,所以需要手动减一,第一章就是 0)e 是结束章节数l 是并发数m 模式b 书的编号test command:node taskHandler.js -s 0 -e 10 -l 3 -b 5443*/program .version(&apos;0.1.0&apos;) .option(&apos;-s, --start [start]&apos;, &apos;start chapter&apos;, 0) .option(&apos;-e, --end [end]&apos;, &apos;end chapter&apos;) .option(&apos;-l, --limit [limit]&apos;, &apos;limit async&apos;, 3) .option(&apos;-m, --mode [mode]&apos;, &apos;Add bbq sauce&apos;, 2) .option(&apos;-b, --book [book]&apos;, &apos;book number&apos;) .parse(process.argv);/* 第一步获取章节连接,第二部获取章节内容并进行输出 输出方式一 输出到数据库.(未实现) 输出方式二 文件输出(在关注react-pdf,希望支持pdf输出)*/if (!program.book) &#123; return&#125; else &#123; cmd = `node fetchAllChapters.js -b $&#123;program.book&#125;`;&#125;if (!program.start || !program.end) &#123; console.log(&quot;must input with start-chapter and end-chapter &quot;) return;&#125;//(async function() &#123; let stdout = &apos;&apos; await execAsync(cmd, &#123; //default value of maxBuffer is 200KB. maxBuffer: 1024 * 500 &#125;); console.log(111) await fs.readFile(&apos;./mock/bookInfo.json&apos;,function(err,res)&#123; if(err)&#123; console.error(&apos;write error&apos;); &#125; stdout = res.toString() console.log(222) console.log(333) let data = JSON.parse(stdout), start = parseInt(program.start), end = parseInt(program.end), limit = parseInt(program.limit), dataList = data[&apos;dataList&apos;], fetchResult = null; //use to debug // let dataList = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; if (!dataList || data.length &lt;= 0) &#123; return &#125; console.log(444) //分发任务 每10s调取一次并发抓取10条记录 //截取需要的章节数 /*根据章节,章节是一开始,默认无序章*/ //dataList, start, end, limit //下面是抓每章内容 try &#123; fetchResult = delayAsync(dataList, start, end, limit); console.log(fetchResult) &#125; catch (e) &#123; console.log(e) &#125; &#125;)&#125;)()const exec = require(&apos;child_process&apos;).exec;const execAsync = require(&apos;async-child-process&apos;).execAsync;const async = require(&apos;async&apos;)const delayAsync = require(&apos;./asyncFetch&apos;).delayAsync;const program = require(&apos;commander&apos;);var fs = require(&apos;fs&apos;);const util = require(&apos;util&apos;)const co = require(&apos;co&apos;)const readAsync = util.promisify(fs.readFile)let cmd;/*s 是章节开始(下标是0,所以需要手动减一,第一章就是 0)e 是结束章节数l 是并发数m 模式b 书的编号test command:node taskHandler.js -s 0 -e 10 -l 3 -b 5443*/program .version(&apos;0.1.0&apos;) .option(&apos;-s, --start [start]&apos;, &apos;start chapter&apos;, 0) .option(&apos;-e, --end [end]&apos;, &apos;end chapter&apos;) .option(&apos;-l, --limit [limit]&apos;, &apos;limit async&apos;, 3) .option(&apos;-m, --mode [mode]&apos;, &apos;Add bbq sauce&apos;, 2) .option(&apos;-b, --book [book]&apos;, &apos;book number&apos;) .parse(process.argv);/* 第一步获取章节连接,第二部获取章节内容并进行输出 输出方式一 输出到数据库.(未实现) 输出方式二 文件输出(在关注react-pdf,希望支持pdf输出)*/if (!program.book) &#123; return&#125; else &#123; cmd = `node fetchAllChapters.js -b $&#123;program.book&#125;`;&#125;if (!program.start || !program.end) &#123; console.log(&quot;must input with start-chapter and end-chapter &quot;) return;&#125;//(async function() &#123; let stdout = &apos;&apos; await execAsync(cmd, &#123; //default value of maxBuffer is 200KB. maxBuffer: 1024 * 500 &#125;); console.log(111) await fs.readFile(&apos;./mock/bookInfo.json&apos;,function(err,res)&#123; if(err)&#123; console.error(&apos;write error&apos;); &#125; stdout = res.toString() console.log(222) console.log(333) let data = JSON.parse(stdout), start = parseInt(program.start), end = parseInt(program.end), limit = parseInt(program.limit), dataList = data[&apos;dataList&apos;], fetchResult = null; //use to debug // let dataList = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; if (!dataList || data.length &lt;= 0) &#123; return &#125; console.log(444) //分发任务 每10s调取一次并发抓取10条记录 //截取需要的章节数 /*根据章节,章节是一开始,默认无序章*/ //dataList, start, end, limit //下面是抓每章内容 try &#123; fetchResult = delayAsync(dataList, start, end, limit); console.log(fetchResult) &#125; catch (e) &#123; console.log(e) &#125; &#125;)&#125;)() 这里是将两个模块结合起来,先抓取所有章节数再进行处理 这里使用async-child-process调起子进程,然后直接获取输出在控制台中的数据作为输出结果,由于async-child-process默认控制台输出的最大字节流是5kb所以要调整最大字节流的限制,不然会报错; 结合async 与计时器实现延迟并发加载 这里先要说一下async.js这个库提供了许多控制并发的方法,关于async的demo可以看一下唐大大的async demo,里面有许多async method 的使用 🌰 而我们在这里使用的是 async.mapLimit() 1234567891011121314151617181920212223242526272829303132333435363738/*mapLimit(coll, limit, iteratee, callbackopt)params coll 是数据集合 limit 并发数量 iteratee 迭代器fun(fun 提供item 和callback,通过ca) callcackopt collection执行完毕或者是错误出现执行的回调函数A callback which is called when all iterateefunctions have finished, or an error occurs. Results is an array of the transformed items from the coll. Invoked with (err, results).*///var arr = [&#123;name:&apos;Jack&apos;, delay:200&#125;,&#123;name:&apos;Mike&apos;, delay: 100&#125;, &#123;name:&apos;Freewind&apos;, delay:300&#125;, &#123;name:&apos;Test&apos;, delay: 50&#125;];async.mapLimit(arr,2, function(item, callback) &#123; log(&apos;1.5 enter: &apos; + item.name); setTimeout(function() &#123; log(&apos;1.5 handle: &apos; + item.name); if(item.name===&apos;Jack&apos;) callback(&apos;myerr&apos;); else callback(null, item.name+&apos;!!!&apos;); &#125;, item.delay);&#125;, function(err, results) &#123; log(&apos;1.5 err: &apos;, err); log(&apos;1.5 results: &apos;, results);&#125;);/*20.675&gt; 1.5 enter: Jack20.682&gt; 1.5 enter: Mike20.786&gt; 1.5 handle: Mike20.787&gt; 1.5 enter: Freewind20.887&gt; 1.5 handle: Jack20.887&gt; 1.5 err: myerr20.887&gt; 1.5 results: [ undefined, &apos;Mike!!!&apos; ]21.091&gt; 1.5 handle: Freewind*/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//在看另外一段const async = require(&apos;async&apos;);const moment = require(&apos;moment&apos;);var arr = [&#123; name: &apos;Jack&apos;, delay: 200&#125;, &#123; name: &apos;Mike&apos;, delay: 100&#125;, &#123; name: &apos;Freewind&apos;, delay: 300&#125;, &#123; name: &apos;Test&apos;, delay: 50&#125;];var log = function(msg, obj) &#123; //对log进行了封装。主要是增加了秒钟的输出，通过秒数的差值方便大家对async的理解。 process.stdout.write(moment().format(&apos;ss.SSS&apos;) + &apos;&gt; &apos;); if (obj !== undefined) &#123; process.stdout.write(msg); console.log(obj); &#125; else &#123; console.log(msg); &#125;&#125;async.mapLimit(arr, 2, function(item, callback) &#123; log(&apos;1.5 enter: &apos; + item.name); setTimeout(function() &#123; log(&apos;1.5 handle: &apos; + item.name); // if (item.name === &apos;Jack&apos;) callback(&apos;myerr&apos;); callback(null, item.name + &apos;!!!&apos;); &#125;, item.delay);&#125;, function(err, results) &#123; log(&apos;1.5 err: &apos;, err); log(&apos;1.5 results: &apos;, results);&#125;);/*18.951&gt; 1.5 enter: Jack18.958&gt; 1.5 enter: Mike19.062&gt; 1.5 handle: Mike19.063&gt; 1.5 enter: Freewind19.162&gt; 1.5 handle: Jack19.162&gt; 1.5 enter: Test19.217&gt; 1.5 handle: Test19.367&gt; 1.5 handle: Freewind19.367&gt; 1.5 err: null19.369&gt; 1.5 results: [ &apos;Jack!!!&apos;, &apos;Mike!!!&apos;, &apos;Freewind!!!&apos;, &apos;Test!!!&apos; ]*/ 更直观的看出callcackopt的调用是在error或者全部完成后调用的,result里放着的是每次callback(null,result)调用的结果以数组的形式储存,注意如果某个函数没有使用该回调,在结果里显示就是undefined 至于结束后仍输出,就是异步机制的问题(或者说是cpu调度问题？),已经调起了控制台的输出后 callcackopt才调用 大概了解async.mapLimit的使用后来看一下目前我的实现和存在的问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134const async = require(&apos;async&apos;)const execAsync = require(&apos;async-child-process&apos;).execAsync;/*实现并发抓取的函数*/var asyncFetch = function(data, number, method) &#123; return new Promise(function(resolve, reject) &#123; if (!data || data.length &lt;= 0) &#123; reject(&quot;data not exist&quot;) &#125; let result = []; async.mapLimit(data, number, async(data, callback) =&gt; &#123; //需要设置延时不然ip会被封掉 let cmd = `node fetchChapter.js -u $&#123;data.link&#125; -f -p`, json, //获取一个内容就输出一个 &#123; stdout &#125; = await execAsync(cmd, &#123; //default value of maxBuffer is 200KB. maxBuffer: 1024 * 500 &#125;); /*将内容保存到json中*/ json = JSON.parse(stdout); //保存index json.index = data.index; /* 由于设置成了async,出现了多次触发err的情况,callback 不能正常工作, 手动推入result中,但是这样顺序是不确定的,有待解决这个问题 */ result.push(json); callback(null, json) //not work &#125;, function(err) &#123; //回调函数在全部都执行完以后执行 if (err) &#123; reject(err) &#125; resolve(result) &#125;) &#125;) &#125; /*实现延时加载的函数*/var delayAsync = function(dataList, start, end, limit) &#123; return new Promise(function(resolve, reject) &#123; var result = [], counter = 0, checkTimer, checkTimeOut, fetchTimers = [], count = Math.ceil((end - start) / limit), remain = start - end, i = 0; if (dataList.length &lt;= 0) &#123; //数据长度为空就返回 reject(&quot;error&quot;) return; &#125; //打印一下输入情况 console.log(dataList) try &#123; /*章数的开始和结束*/ console.log(`从$&#123;start&#125;到 $&#123;end&#125;`) let startIndex = start, endIndex; while (startIndex != end) &#123; /* 需要注意的是当剩余的任务不足以达到并发数的时候 要保证任务分割不能出界 */ if (startIndex + limit &lt; end) &#123; endIndex = startIndex + limit; &#125; else &#123; //截取出界 endIndex = end; &#125; /*分割任务*/ chapter = dataList.slice(startIndex, endIndex); //通过闭包实现IIFE保存当时抓取的情况,不使用闭包绑定的数据则是运行之后的值 (function(startIndex, endIndex, chapter) &#123; //通过tempTimer 保存下来 let tempTimer = setTimeout(async function() &#123; //获得此次任务开始执行的时间 let startTime = new Date(), time, chapterResult = []; //进行并发捕获执行命令 try &#123; chapterResult = await asyncFetch(chapter, limit); &#125; catch (e) &#123; // console.log(e) &#125; result = result.concat(chapterResult) //用于判断任务标记 counter++; time = new Date() - startTime; console.log(`完成抓取 $&#123;startIndex&#125; 到 $&#123;endIndex&#125; 计数器是$&#123;counter&#125; 时间是$&#123;time&#125;`) &#125;, i * 1000); fetchTimers.push(tempTimer); &#125;)(startIndex, endIndex, chapter) i++; //控制延时 //推进任务进行 startIndex = endIndex; &#125; &#125; catch (e) &#123; reject(e) &#125; /*定时判断任务是否完成*/ checkTimer = setInterval(function() &#123; console.log(`counter is $&#123;counter&#125; count is $&#123;count&#125;`) if (counter == count) &#123; //清除定时器 clearTimeout(checkTimeOut); //清除定时器 clearInterval(checkTimer); resolve(result) &#125; &#125;, 1000); //or use promise all ? //30s计时器判断超时,超时时间暂做距离 checkTimeOut = setTimeout(function() &#123; //超时清除所有定时器 for (let i = 0; i &lt; fetchTimers.length; i++) &#123; clearTimeout(fetchTimers[i]); &#125; //清除定时判断 clearInterval(checkTimer); console.log(&quot;timout&quot;) reject(result) &#125;, 30000); &#125;)&#125;module.exports = &#123; asyncFetch: asyncFetch, delayAsync: delayAsync,&#125; 目前在async中存在问题,callback函数不能正常工作,所以每次都是手动将结果推入结果集,导致结果集的顺序不能和原数据顺序对应, 然而async官方文档中 The callback must be called exactly once, ideally on a later tick of the JavaScript event loop. 至少要调用一次callback？ 但是 在延时并发中考虑用await Promise.all[] 取代定时器判断任务是否结束 输出结果 获取章节保存到本地json文件中 这里使用的node的fs文件的fs.writeFile模块 反思 书本的章节可以捕获一次保存在/mock/bookInfo.json本地文件中,输入书本后判断书本是否已经捕获过章节了 捕获过就从本地文件/mock/bookInfo.json中获取需要的章节,提供方法检验是否有最新章节, 以文本形式储存阅读并不方便,如何更方便的阅读 在大量捕获的时候仍会被封停,缺少应对封停的机制 添加phantom proxy 进行代理,这里引出需要写一个抓取代理并测试的服务来提供代理池 参考 本文参考]]></content>
      <categories>
        <category>前端</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>爬虫</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[About Programmer's Novel]]></title>
    <url>%2F2019%2F04%2F26%2Fprogrammer-novel%2F</url>
    <content type="text"><![CDATA[本文产生自知乎一话题“怎么写出一本程序员风格的修真小说？” 终有一天我手中的编译器将成为我灵魂的一部分，这世界在我的眼中将被代码重构，我将看到山川无尽银河无垠都汇成二进制的数字河流，过往英雄都在我脑海眼前一一浮现，而我听到无数码农跪倒在我的程序面前呼喊。 他们叫我代码之神。 到那个时候，我想我一定可以找回你。 一、属于代码世界。 这是一个属于代码的修真世界。 这世界里的每一个人，每一个东西，包括高山大海，刀剑风云，其本质都是一串数字流。 打个比方，如果你知道一块石头的内部数据结构，并且参透其中玄妙，你就能用程序改变它的一切。如果能参透自身这一个复杂的操作系统，就能重新编码自己，获得更大的能力。 所以你的程序水平的高低，决定了你的牛逼程度。 我们这些修真者，都叫程序员。 有人的地方，就有江湖。有江湖的地方，就有代码。 刚入门的时候，师傅跟我说，我们程序员修的，是一份境界。短短几句的代码里，要有最完美的逻辑，跟最精妙的算法。这本《算法导论》，你暂且拿去研修。 我们程序员，外修语言，内修算法。以数据为根，算天算地算自己。 听起来真的好酷。 但这个江湖，并不平静。几大门派，上有微软谷歌，下至百度阿里，每个门派风格迥异，暗地里都有无数摩擦。 师傅说，我们知乎派，理论见长。三大软狗、哦不，三大软神坐镇，还有无数默默搬砖的程序员，如今也算在乱世立稳了脚跟。 师傅还说，江湖虽乱，但我们修真之人，说到底还是要修自身，恩恩怨怨都是过眼云烟，自身境界才是万源之本。 我点了点头。 师傅又拍了拍我的小脑瓜，慈祥一笑。他说，如果下次天涯派那群人还过来闹事，我们一定要秉承我们的自身理念来处理他们。 我知道了，我回师傅道，我跟刘看山一定会好言相劝，么么他们个哒哒。 不。师傅转身过来，鹰眼之中精光毕露，胡须颤动的嘴唇之中，一个字一个字地吐出来。 灰飞烟灭，一个不留。 二、初识 自我开始修真起，我练的便是C++的功夫。 虽然大师兄跟我说过，不管你学的事什么语言，都是殊途同归。我们修真之人，都不要在乎这些差别，要参透的是程序的本质。 然后他又说，不过，用Java的都是傻逼。 大师兄跟我一样，C++的功底深厚，面向对象的各种技能用的精通，只是可惜，他还没有对象。 我永远忘不了那一天，我们知乎派的山门被一众凶恶之徒所踏破，山石飞舞，浮尘弥漫，门派服务器都暂停运行。 大师兄坐在大殿房顶之上，喝一壶陈年的竹叶青。姿势潇洒，闷骚至极。 是他们，谁都知道，天涯派不止一次来闹事。 我从来没见过大师兄出过手。 天涯派的来人，在烟尘之中现出数个魁梧身影，还夹带了一声大笑和开场白： 哈哈哈哈哈哈哈，知乎派，hello world！ 大师兄的眼皮都没有眨一下。 他的右手之上字符串环流浮现，左手抬起酒壶一饮而尽，右手对着虚空就是一指，那一串字符都消散在空气之中。 刹那间风云突变，一阵狂风似有形一般，沿着大师兄所指方向似一条狂龙横冲了过去，一个照面便将几个大汉吹得撞出山门之外，摔了个七荤八素。 那一霎我屏住呼吸 大师兄整了整风中凌乱的发型，说，这就叫快速傅里叶变换，将风压重新编码，所到之处，寸草不生。你们都还在解码自己，我已经开始操纵世界——天涯跟知乎，就是在这里的差距，懂？ 都他妈的给老子滚 从那一刻开始，我才知道，有些人已经可以编码这个世界本身。 这才是叫修真。 三、修行 在知乎里修行了十年，师傅说我可以下山了。 我已经熟知C++的基本技能，但师傅告诫我千万不要说自己精通C++。他说，这世界上，没有人可以说，他已经精通C++，所以即算你装逼的时候，也要装得像个样子。比如，你可以说你精通java。 我点头称是。 这十年来，我每日苦读《算法导论》和《C++ primer》，精通数据库原理跟操作系统，同龄人之中无人是我敌手，自认为天下哪里都可去得。 是为年轻气盛，是为势不可挡。 我下山之后，连连在江湖之中，将一些有一点点小名气的程序员斩于马下。 他们之中，有些是根基不稳，有些是反应迟钝，有些是冥顽不灵，有些是莽撞愚蠢。 当然，我现在说起来是云淡风轻，那是因为我在装逼。其实也经过了一番苦战，有过一些辛酸。终于有一天，我将天下程序员排行榜第一千位的马特给击败，成功登上天下程序员排行榜。 马特这个程序员，有一些狡猾。他占据第一千位，已经很久没有变过。他精通计算机图形学，经常使用一些幻境击败对手。他比他上面几位更加难缠，所以通常没有人会去挑战他。因为你赢了他，也只能到第一千位，还不如去挑战他上面的更划算一些。 可惜他遇到了我，因为我比他，更精通计算机图形学。 于是这也成为一个不大不小的消息，在江湖里传播，从此我有了一个外号，他们叫我杀马特。 俗话说树大招风，人不能太出名。 有一天看到一个酒馆，我走进去，一个风情万种的女人转过来，她问我，客官，你要喝点什么嘛？ 我说，三两竹叶青。 正当我在喝酒的时候，来了一群穿着黑衣的程序员。 这群人，个个怪异，但水平很高。 江湖之中，穿黑衣的程序员，都叫黑客。 来者不善。 他们将我围起来，为首的一人说，他们是做安全的。 我心中陡然一惊。因为我看到了他们衣服里藏着的，三百六十度的环形刀刃。 一百年前，有一个叫奇虎的门派。他们每个人，都有一把神秘的三百六十度的环形刀刃，所以也叫奇虎三六零。他们声称他们的存在，是为了防止世界被破坏，为了保护世界的和平，是为了贯彻爱与真实的勇敢，他们是穿梭在江湖中的三六零。但他们却暗中做了无数秘密勾当，后来江湖人人称之魔教，BAT三大派跟一些其他门派联手围上光明顶，将其灭门。 当然，我们知乎派，也在之中出了不少的力量。 我皱眉喝酒，问他们所为何事。 那为首一人，拿过我的酒壶，仰头一灌。最后一滴酒在壶中滴落之时，无数环形刀刃在我身边出现，他的手中也倏地出现一把，朝我迎面砍来。 竟是偷袭。 刀刃之上闪过的代码我毕生未见，锋利无比，威力惊人。 我虽鼓动全身能量，瞬间编译，但也感觉凶多吉少。 这电光火石一瞬间，只听得铛地一声，数把环形刀刃通通弹落一边，那些黑衣怪人通通倒地。 我靠，我有这么强？ 只听得酒馆二楼悠悠传来一个女声。要打去别的地方打吧，进来酒钱都没付，还要打我的客人，这是何理？ 原来是酒馆的女老板。 她从二楼飘飘而落，将我身边灰尘一扫而空，朱唇轻启，哎呀，吓到小哥你了，真是对不起。 我以前听师傅说，对于程序员，只有两种东西是天敌。一种是御姐，一种是萝莉。我说我不信。 我现在信了。 四、结衣 女老板说，可以叫她结衣。 她问我叫什么，我嘟哝了半天，我说我叫杀马特。 结衣说哈哈哈哈哈哈哈你真可爱。 我说结衣，你怎么会这么强。 她说你不懂，我一个弱女子，不懂点编程之术，在这江湖里怎么开酒馆嘛。 我说结衣，你怎么这么好看。 结衣不说话了。 结衣说，你这个小流氓。 我说结衣，师傅说，我们程序员只有两种天敌，一叫御姐，二是萝莉，你是哪一种？ 结衣说，我都不是。 我说，哦。其实我心里想着的，是你都是。 结衣，你跟我一起闯荡江湖去好不好？ 不好，你还没我强。 哦。那等我比你强了，我们一起去闯荡江湖好不好？ 结衣笑了一下说，不好。 于是我就住在了酒馆里。 因为我可能，爱上了这个女人。 我杀马特曾经以为，我这一辈子就只能爱上一个女人。后来我才知道，这世间有万千代码，万物都可编译，但你编译不了的，是自己的心。 结衣是一个看上去很好强，八面玲珑的女人。她的编程水平，比那些排行榜上五百位之后的怂蛋，不知道高到哪里去了，但是她却在这里经营一个小酒馆。 我曾经问过为什么，但是结衣不说。 她只说她在等人。 我想问她是不是在等她的意中人，但是又不好意思开口。我怕是的，那我可能要伤心。师傅说修真的程序员，不能伤心。伤心的程序员，写不出好的代码。 所以我也只能等。 终于等到有一天，那天酒馆外面都是黑漆漆的云，空气里都是紧张的、像墨水混合了砂子一样的味道。可能有沙尘暴。 结衣一脸严肃。 我说结衣，咱们把门关上避一避。 结衣一言不发，站在门口，看向远方。 过了一阵，远处黑云之中，竟然出现一个人影。霎时间，雷光闪动，暴雨如注。 结衣看了我一眼，转身腾空就飞了出去。朝着远处的黑云人影，鼓动着浑身能量，就这么飞了出去。 我大喊一声结衣，然后也跑了出去。雨越下越大，我只能隐隐看见远处电闪雷鸣，我在混乱之中大喊结衣。 他们在交战。 远处代码一行行在云端飞舞盘旋，命令与字节化为巨大的力量，我没有想到结衣竟然强到这个地步。 举手投足，山河变色。 我想起大师兄所说的，有人还在解码自身，有人已经操纵世界。 是一场恶战。 我只能站在下面看，我甚至都不知道他们交战的具体情况。 我心急如焚。 在一个天际的惊雷响彻之后，一道正弦函数冲击波将所有黑云弹射开来，而我只看到结衣在空中坠落的身影。 拨云见日，阳光普照。 在很多年之后，当我再回想起这个情形，还是觉得，即算是临死之时的结衣，在空中的身影，也那么美好。 我抱着结衣，泣不成声。 她看着我，怔怔的看着我。 她说你别哭，真的，这是注定的一天。 她说我们家以前侵入国防系统，被朝廷发现灭门，我侥幸逃脱。但是不管我在哪里，总有一天他们会找上来。 她说你是男孩子，要坚强一点。不坚强一点，你怎么成为最好的程序员。 结衣在那几分钟里，好像想把她一生没讲完的话，都给讲完。 她说的最后一句话是，杀马特，你一定不要忘了我。 然后她就再也没有说话了。 我甚至都没有问过她说，你有心上人吗？ 我甚至都没有跟她说过，我是真的很喜欢你。 我甚至都没有吻过她，没有牵过她的手，我们只是这样匆匆遇到，然后匆匆告别。 她的身体将化成一串数字流，失去结构，流向无尽的原野、河流跟大地，化为三月的春风、杨柳跟雨滴。 有些东西，是命。 我的整个程序员修真生涯，在这一天，被分割开来。 对，我杀马特，在这一天之后，是一个一定要成为天下第一的程序员。 为了结衣。 五、宗门 并非是单单想给结衣报仇。 我们程序员的修真之路，内修自己，外修天地。 当代码可以操控天地这个最为复杂的系统之时，就一定会涉及到世界的本源之处。若这个世界的代码在我眼前一览无遗，或许我可以控制时间。 或许我可以从时间的bug里，找回结衣。 这是我这么多年来的，唯一念想。 毕竟我们程序员，生来就要逆天改命。 之后的时间里，我从程序员排行榜上一路飙升，五年之后跻身前十，成为世界上最优秀的程序员之一。 我树敌无数，也击败无数敌人。他们之中，甚至有自创一门语言的奇才，有号称已然精通C++的装逼犯，有对各类操作系统跟编译原理都熟悉无比的怪才，但是，不管谁，都无法阻挡我杀马特的脚步。 无人可挡。生来彷徨。 但，即算是到了我这样的水准，我也依旧无法知道，如何寻找这个世界里时间的bug，甚至都没有一丝头绪。 每逢debug的夜晚，我都会想起结衣，明媚如歌的笑容，和她从天而落，如佛光普照般的美丽。 但这又时时提醒了我，我可能真的已经离她远去了，而我无能为力。 这世间我认识的高手，都无法为我解答这个问题。 直到有一天，我在山间遇到一个红衣人。 他是个高手，从看到他码出第一行代码的时候，我就知道，这是个绝顶高手。 山野相逢，抛却了身份。我跟他把酒言欢，知无不谈，倒也痛快。 直到我跟他说起关于这世界里，时间的bug。 他说，这世界极有可能是在一个环形循环之中。说罢他从怀里掏出一把刀，却正是奇虎派的那把三百六十度环形刀刃。 他说你看这把刀，我派毕生所愿，即是参透这世界的圆之循环，重新编码，到时候天下唾手可得。 我说，我不想要什么天下，我只要一个女人。 红衣人哈哈大笑，说，那你加入我们，来我奇虎参透这世界运行之时最底层的命令，参透这循环，说不定你就能重新遇到那个女人。 对，我没有犹豫，我答应了。 他说，他叫周红衣。 六、大师兄 我就这么加入了奇虎三六零。 彼时奇虎正在重整旗鼓，周红衣想要东山再起，他不能少了我这个助力。 从此我手里多了一把，三百六十度的，环形刀刃。 萧萧狼烟，江湖恩怨再起。 人在江湖，真的身不由己。 我一边参悟奇虎派祖传的代码跟算法，一边帮奇虎派征战天下。 我是知乎派出身，根正苗红，师傅知我落入魔教之手，吐出一口老血。孽徒，孽徒啊。他们也曾劝降，但我不为所动。 我心中，有我自己的编程之道。 所以我很清楚自己在干什么。我很清楚，男孩子，要坚强。 奇虎的势力扩张得很快，但正邪势不两立，BAT三大派见天下形势如此，便要集结程序员部队，重新再上一次光明顶。 他们说，一百年前能灭的，现在也能灭。 光明顶，是我奇虎派的大本营。 而他们带队之人，正是当今天下排行第一的程序员，出身知乎、神龙见首不见尾的大师兄。 大师兄，真的好久不见。 说实话，虽从一开始，我便知道自己背负的是什么，但我也并未想过，有一天要跟大师兄动手。也许在成为男人的路上，杀死偶像，都是不可避免的一环。 大师兄还是酒壶一把，桀骜不驯。他说傻小子，你现在过来，还真的来得及。 我说大师兄，皇皇天下，哪有什么正邪分家。无非是你来我往，你抢我杀。咱们做程序员的都知道，手底下见真章。 大师兄喝酒，哈哈大笑，他说你有长进，然后把酒壶朝天一扔。 1Talk is cheap，show me the code。 七、奇点 与大师兄交战之前，我正参悟到这个世界代码的一些关键之处。 如今一战，倒是针尖对麦芒。大师兄的编程能力，已然步入化境。代码不在手上，已在心中。物质都是数据，规则都是代码，一时间天地轰隆，流云沐风皆能当锋利兵器，重力气压都能做任意改变，我跟大师兄从天到地，战了个平分秋色。 大师兄说，没想到你小子这么难缠。 大师兄说，对不起，我必须解决掉你。 为了正义。 我从没见他说过对不起，这正如他一定会放一个前所未见的大招一样可怕。 大师兄操纵无数代码，打入大地之中，蓦地瞬间，我感觉脚底重力似乎加大了无数倍。 好沉。 好一个无限重力流。 我们这边的程序员，要么被强大重力挤压变形，最舒服的也寸步不能动弹。 大师兄竟然还没有结束，他接着操纵无数代码，打入遥远天空之中，竟从无垠星海之中召来巨大陨石。 陨石当空，重力无限。 这两者相结合，他竟凭他一人之力，要横扫整个奇虎。 不愧是天下第一的旷世奇才。我承认，面对这样的攻势，我并没有什么好的办法。 但我也不后悔。 既然踏上这条路，我就没有打算过回头。 陨石从我头上落下之时，生死交错的瞬间，我仿佛又看到结衣的脸，像电影一般飞驰而过的场面。 我突然领悟到些什么。 我在那一瞬也打出无数代码，我打出的代码，跟大师兄的，一模一样。 复制代码，通常比较容易。 我脚下重力瞬间又加大无数倍，其他的程序员早已不堪重负，化为一摊数据流。而那个陨石速度越来越快，擦出巨大的热浪火花，空间都变形扭曲，周围一切化为粉末，消散无形。 我以为那个瞬间我已经死了。 而我在那一个瞬间，看到了在弯曲变形的前方，有一个时空的奇点。 时间是一个圆。 我靠近它，向死而生。 前方白光一片。 八、重启 我睁开眼。 眼前是那个熟悉的酒馆。 我走进去，一个风情万种的女人转过来。 她问我，客官，你要喝点什么嘛？ 九、完 1//重启万能大法好]]></content>
      <categories>
        <category>文学</category>
        <category>小说</category>
      </categories>
      <tags>
        <tag>文学</tag>
        <tag>小说</tag>
        <tag>程序员小说</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信内置浏览器 非全屏播放视频解析]]></title>
    <url>%2F2019%2F04%2F25%2Fwx-video-x5%2F</url>
    <content type="text"><![CDATA[前提条件 接了一个项目要实现在微信公众号里课程播放，而且还有评论功能，视频需要小窗播放。 首先公布解决方案： 12&lt;video id=&quot;my-video&quot; class=&quot;video-js&quot; controls preload=&quot;auto&quot; width=&quot;100%&quot; height=&quot;300px&quot; x5-playsinline=&quot;&quot; playsinline=&quot;&quot; webkit-playsinline=&quot;&quot; poster=&quot;&quot; preload=&quot;auto&quot;&gt;&lt;/video&gt; 解决过程 网上百度一把片，主要是这些属性，给赋值true之类的，然而没什么卵用 123456webkit-playsinline=&quot;true&quot; /*这个属性是ios 10中设置可以让视频在小窗内播放，也就是不是全屏播放*/ playsinline=&quot;true&quot; /*IOS微信浏览器支持小窗内播放*/ x-webkit-airplay=&quot;allow&quot; x5-video-player-type=&quot;h5&quot; /*启用H5播放器,是wechat安卓版特性*/ x5-video-player-fullscreen=&quot;true&quot; /*全屏设置，设置为 true 是防止横屏*/&gt; x5-video-orientation=&quot;portraint&quot; /*播放器支付的方向，landscape横屏，portraint竖屏，默认值为竖屏*/ 还有用canvas解决的，代码可以给你们参考写是我从csdn花了3C币买的 请自动引入jq等插件库 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;meta name=&quot;author&quot; content=&quot;Tencent-TGideas&quot;&gt; &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no,minimal-ui&quot;/&gt; &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt; &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot; /&gt; &lt;title&gt;直播&lt;/title&gt; &lt;style&gt; *&#123; margin:0; padding:0; box-sizing:border-box;&#125; html&#123; max-width:640px; min-width:320px; margin:0 auto;&#125; img&#123; max-width:100%; vertical-align:middle;&#125; .video_box&#123; width:100%; position:relative;&#125; .start_video&#123; width:40px; height:40px; border-radius:50%; background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAH4AAAB+CAYAAADiI6WIAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyFpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDE0IDc5LjE1MTQ4MSwgMjAxMy8wMy8xMy0xMjowOToxNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2RjFFNEQzQzYwMkExMUU2OTA2RURBNTIyNDYyMzY0NSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2RjFFNEQzRDYwMkExMUU2OTA2RURBNTIyNDYyMzY0NSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjZGMUU0RDNBNjAyQTExRTY5MDZFREE1MjI0NjIzNjQ1IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjZGMUU0RDNCNjAyQTExRTY5MDZFREE1MjI0NjIzNjQ1Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+/oEh8gAAEclJREFUeNrsXQtQVdUa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) no-repeat center center; background-size:100% 100%; cursor:pointer; position:absolute; left:50%; top:50%; -webkit-transform:translate(-50%,-50%); transform:translate(-50%,-50%);&#125; video&#123; width:100%; vertical-align:middle; object-fit:contain; object-position:left top;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;img src=&quot;http://pic.qiantucdn.com/58pic/11/32/07/98258PIC8dA.jpg&quot; /&gt;&lt;/div&gt;&lt;div class=&quot;video_box&quot;&gt; &lt;!-- 必须加上： x5-video-player-type=&apos;h5&apos; x5-video-player-fullscreen=&apos;true&apos; 否则视频还是跳出去 全屏 播放 poster=&quot;http://ossweb-img.qq.com/images/wefire/act/a20150826kris/bg_poster.jpg&quot; 否则视频的高度可能会出问题 --&gt; &lt;video id=&quot;testVideo&quot; x-webkit-airplay=&quot;true&quot; webkit-playsinline=&quot;true&quot; playsinline=&quot;true&quot; preload=&quot;auto&quot; x5-video-player-type=&apos;h5&apos; x5-video-player-fullscreen=&apos;true&apos; src=&quot;http://ossweb-img.qq.com/images/wefire/act/a20150826kris/v1.mp4&quot; poster=&quot;http://ossweb-img.qq.com/images/wefire/act/a20150826kris/bg_poster.jpg&quot;&gt;&lt;/video&gt; &lt;span class=&quot;start_video&quot;&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot; height:300px;&quot;&gt; &lt;textarea style=&quot; width:100%; height:100%; padding:10px; background-color:#eee; border:none; outline:none vertical-align:middle; resize:none; appearance:normal;&quot; placeholder=&quot;在此输入内容&quot;&gt;&lt;/textarea&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;http://pic.qiantucdn.com/58pic/11/32/07/98258PIC8dA.jpg&quot; /&gt;&lt;/div&gt;&lt;script src=&quot;http://code.jquery.com/jquery-2.0.0.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //判断是否为安卓设备 function isAndroid()&#123; var u = navigator.userAgent; if(u.indexOf(&apos;Android&apos;) &gt; -1 || u.indexOf(&apos;Linux&apos;) &gt; -1)&#123; return true; &#125; &#125; var $video = $(&apos;#testVideo&apos;); $(function()&#123; $(&apos;.start_video&apos;).on(&quot;touchstart&quot;,function()&#123; $(this).hide(); $video[0].play(); &#125;); if(isAndroid())&#123; $video.css(&apos;display&apos;,&apos;none&apos;).after(&apos;&lt;canvas id=&quot;testCanvas&quot; style=&quot;width:100%; vertical-align:middle;&quot;&gt;&lt;/canvas&gt;&apos;); /*以上配置 安卓 机解所需元素及相关属性*/ var videoW , videoH; setTimeout(function()&#123; videoW = $video.width() * 3; videoH = $video.height() * 3; TestCanvas.width = videoW; TestCanvas.height = videoH; setCanvasStartImg(); //之所以这里要播放下，是因为经过测试，第一次点击CANVAS时，视频播放又立即停止了 TestVideo.play(); TestVideo.pause(); console.log(videoW); console.log(videoH); console.log(TestVideo.width); console.log(TestVideo.height); &#125;,100); //设置CANVAS初始画面（视频封面） function setCanvasStartImg()&#123; var plsterImgSrc = $video.attr(&apos;poster&apos;); if(plsterImgSrc)&#123; var plsterImg = new Image(); plsterImg.src = plsterImgSrc; plsterImg.onload = function()&#123; TestCanvas2D.drawImage(plsterImg,0,0,videoW,videoH); &#125; &#125; &#125; /*以下是渲染CANVAS画布中的视频*/ //获取video var TestVideo=document.getElementById(&quot;testVideo&quot;); //获取canvas画布 var TestCanvas=document.getElementById(&quot;testCanvas&quot;); //设置画布 var TestCanvas2D=TestCanvas.getContext(&apos;2d&apos;); //设置setinterval定时器 var TestVideoTimer=null; //监听播放 TestVideo.addEventListener(&apos;play&apos;,function() &#123; $(&apos;.start_video&apos;).hide(); TestVideoTimer=setInterval(function() &#123; TestCanvas2D.drawImage(TestVideo,0,0,videoW,videoH); &#125;,20); &#125;,false); //监听暂停 TestVideo.addEventListener(&apos;pause&apos;,function() &#123; clearInterval(TestVideoTimer); $(&apos;.start_video&apos;).show(); &#125;,false); //监听结束 TestVideo.addEventListener(&apos;ended&apos;,function() &#123; clearInterval(TestVideoTimer); $(&apos;.start_video&apos;).show(); &#125;,false); &#125;else&#123; $video.attr(&apos;controls&apos;,&apos;controls&apos;); &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 总结 解决过程很心酸，结果最起码是美满的，毕竟解决了segmentfault上边所说的微信X5内核不能非全屏播放视频的世界级难题（皮一下，希望不会挨打） 目前这个方法亲测可以使用华为、小米、vivo、苹果、oppo 随手打赏什么不奢望，只是开通一个赞赏功能，当然了请我喝饮料我也不会介意的]]></content>
      <categories>
        <category>前端</category>
        <category>视频</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>video</tag>
        <tag>视频</tag>
        <tag>X5引擎</tag>
      </tags>
  </entry>
</search>
